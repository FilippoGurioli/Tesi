\section{Progettazione dettagliata}\label{sec:progettazione}
In quest'ultima sezione si affronteranno le strutture del progetto nello specifico, analizzando le classi e le loro funzionalità. La trattazione verrà affrontata in ordine di 
creazione delle classi, in modo da collegare questa discussione al \textit{gameplay} del progetto.\\
\newline
Prima di iniziare con la descrizione delle classi, si vuole esporre dei punti chiave comuni lungo tutto il progetto.\\
Seguendo la logica del \textit{single-responsibility principle}\footnote{Single responsibility principle: principio di progettazione software che afferma che ogni modulo o classe deve
essere responsabile di una singola funzionalità.}, si è strutturata una rete di \texttt{Croquet.Model} che distribuisse ogni funzionalità del dominio ad un modello diverso, in modo da tenere separati i compiti e mantenere una
gerarchia ordinata e intuitiva.\\
Altro tassello importante è la decisione di non utilizzare ereditarietà, preferendo la composizione in quanto ritenuta più flessibile e meno vincolante. La struttura si può
raffigurare comunque in una relazione padre-figlio in cui però non è il figlio a estendere il padre, bensì il padre a creare e contenere il figlio.\\
In ultima istanza si sono create delle classi JavaScript ausiliarie all'architettura di Croquet che fungono da supporto per la gestione dei dati. Queste classi sono state create per 
racchiudere al loro interno le caratteristiche più importanti dei concetti da modellare e quindi facilitare la manutenzione e migliorare la leggibilità del codice.\\

\subsection{Root}\label{subsec:rootclass}
Il \texttt{RootModel} e la \texttt{RootView} sono le prime classi create nel progetto. Queste classi sono state create con la funzione di modellare una scena di base da cui far
partitre l'utente, per creare una separazione tra il collegamento alla sessione e l'inzio del gioco vero e proprio. L'obiettivo era infatti quello di rendere la gestione delle
connessioni più semplice e logico.\\
Il \texttt{RootModel} nello specifico tiene traccia di tutte le view che si collegano alla sessione, in modo da creare un'istanza del gioco all'avvento della prima view collegata e 
distruggere il gioco alla disconnessione dell'utlima view. Fornisce anche il metodo \texttt{restart} che consente di riavviare la simulazione in caso di fine gioco ma ancora utenti 
connessi.\\
La classe \texttt{RootView} si occupa di creare la scena di base, ovvero quella che l'utente vede prima di iniziare il gioco. Questa consiste semplicemente di un bottone che, se 
premuto, avvia la simulazione vera e propria. Seppur possa sembrare abbasta inutile, la parte più importante di questa classe risiede nel \textit{dietro alle quinte} della scena. 
Qui infatti si crea e avvia un \textit{rendering-loop}, ovvero un ciclo infinito che aggiorna la scena ad ogni frame, l'\textit{engine}, la scena, la telecamera, la luce e tutta
una serie di funzionalità dedite al corretto avvio di una scena XR (se è stato rilevato un dispositivo affine).\\
Queste due classi sono le uniche in tutta la \textit{codebase} a non autodistruggersi all'avvento del `game over'. Se così non fosse, al termine della partita l'utente si ritroverebbe
con una schermata vuota e dovrebbe ricaricare la pagina per avviare una nuova sessione. Per aggirare il problema si è deciso di cambiare il comportamento che hanno queste classi al 
termine della partita, facendo sì che ricreino la scena (e anche i dati) da zero.\\

\subsection{Game}\label{subsec:game}
Le classi \texttt{GameModel} e \texttt{GameView} sono le classi principali del progetto e fungono da raccordo tra le tutte le altre. Il loro principale compito è quello di creare
tutti i tasselli che compongono il videogioco e svolgere funzionalità ad alto livello come l'assegnazione del ruolo e la gestione delle connessioni.\\
Il \texttt{GameModel} ha il compito di assegnare un ruolo all'utente che si connette alla sessione. Questo ruolo può essere di \textit{player 1}, \textit{player 2} o \textit{spettatore} in 
base al numero di utenti già connessi. Inoltre, se un utente dovesse disconnettersi, questa classe gestisce una sua possibile riconnessione come anche una sequenza di terminazione nel
caso in cui l'utente non dovesse riconnettersi in breve. Come già detto il \texttt{GameModel} ha anche il compito di istanziare tutti i modelli del gioco, ovvero: \texttt{Player},
\texttt{LifePoints}, \texttt{Hand}, \texttt{Turn} e \texttt{Battlefield}.\\
La \texttt{GameView} non crea nessun tipo di oggetto di scena bensì si limita a riposizionare la telecamera dell'utente in base al ruolo che gli è stato assegnato. Successivamente istanzia
tutte le view corrispondenti ai model citati in precedenza.\\

\subsection{Player}\label{subsec:player}
Le classi \texttt{PlayerModel} e \texttt{PlayerView}, similmente alle classi `Game', sono classi che fanno da centro per tutte le altre che gestiscono un aspetto particolare del giocatore.
Queste classi non hanno nessuna funzione di business, il loro impiego è stato voluto per mantenere organizzato il codice. Da queste classi si sviluppano quindi \texttt{LifePoints} e
\texttt{Hand}.\\

\subsection{LifePoints}\label{subsec:lifepoints}
Le classi che modellano i \textit{lifepoints}, ovvero i punti vita dei giocatori, sono \texttt{LifePointsModel} e \texttt{LifePointsView}.\\
Il \texttt{LifePointsModel} sfrutta una classe ausiliaria chiamata \texttt{LifePoints} che racchiude tutte le funzioni e informazioni necessarie per gestire i punti vita di un giocatore.
Seguendo il regolamento, ogni giocatore inizia con 8000 punti vita, può guadagnarne all'infinito e perderne fino ad arrivare a 0. Il \texttt{LifePointsModel} mappa tutta l'API creata
in \texttt{LifePoints} e la rende disponibile alle view con la \textit{feature} in più di lanciare l'evento `game-over' quando un giocatore perde tutti i punti vita. Dato che possono
esserci vari modi per perdere e guadagnare punti vita si è deciso di mappare questi metodi ad eventi correlati.\\
La \texttt{LifePointsView} si occupa di creare un \textit{holographic slate}, ovvero un pannello nativo dell'MRTK framework integrato in BabylonJS, che mostra i punti vita dei giocatori.
Questo pannello sarà personale di ogni giocatore e mostrerà a sinistra i punti vita del proprietario mentre a destra quelli dell'avversario. Si è anche prevista la possibilità che il
pannello fosse ancorato al braccio nel qual caso l'\textit{hand tracking feature} fosse disponibile.\\

\subsection{Hand}\label{subsec:hand}
\subsection{Turn}\label{subsec:turn}
\subsection{Battlefield}\label{subsec:battlefield}
