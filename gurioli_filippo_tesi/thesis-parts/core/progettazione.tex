\section{Progettazione dettagliata}\label{sec:progettazione}
In quest'ultima sezione si affronteranno le strutture del progetto nello specifico, analizzando le classi e le loro funzionalità. La trattazione verrà affrontata in ordine di 
creazione delle classi, in modo da collegare questa discussione al \textit{gameplay} del progetto.\\
\newline
Prima di iniziare con la descrizione delle classi, si vuole esporre dei punti chiave comuni lungo tutto il progetto.\\
Seguendo la logica del \textit{single-responsibility principle}\footnote{Single responsibility principle: principio di progettazione software che afferma che ogni modulo o classe deve
essere responsabile di una singola funzionalità.}, si è strutturata una rete di \texttt{Croquet.Model} che distribuisse ogni funzionalità del dominio ad un modello diverso, in modo da tenere separati i compiti e mantenere una
gerarchia ordinata e intuitiva.\\
Altro tassello importante è la decisione di non utilizzare ereditarietà, preferendo la composizione in quanto ritenuta più flessibile e meno vincolante. La struttura si può
raffigurare comunque in una relazione padre-figlio in cui però non è il figlio a estendere il padre, bensì il padre a creare e contenere il figlio.\\
In ultima istanza si sono create delle classi JavaScript ausiliarie all'architettura di Croquet che fungono da supporto per la gestione dei dati. Queste classi sono state create per 
racchiudere al loro interno le caratteristiche più importanti dei concetti da modellare e quindi facilitare la manutenzione e migliorare la leggibilità del codice.\\

\subsection{Root}\label{subsec:rootclass}
Il \texttt{RootModel} e la \texttt{RootView} sono le prime classi create nel progetto. Queste classi sono state create con la funzione di modellare una scena di base da cui far
partitre l'utente, per creare una separazione tra il collegamento alla sessione e l'inzio del gioco vero e proprio. L'obiettivo era infatti quello di rendere la gestione delle
connessioni più semplice e logico.\\
Il \texttt{RootModel} nello specifico tiene traccia di tutte le view che si collegano alla sessione, in modo da creare un'istanza del gioco all'avvento della prima view collegata e 
distruggere il gioco alla disconnessione dell'utlima view. Fornisce anche il metodo \texttt{restart} che consente di riavviare la simulazione in caso di fine gioco ma ancora utenti 
connessi.\\
La classe \texttt{RootView} si occupa di creare la scena di base, ovvero quella che l'utente vede prima di iniziare il gioco. Questa consiste semplicemente di un bottone che, se 
premuto, avvia la simulazione vera e propria. Seppur possa sembrare abbasta inutile, la parte più importante di questa classe risiede nel \textit{dietro alle quinte} della scena. 
Qui infatti si crea e avvia un \textit{rendering-loop}, ovvero un ciclo infinito che aggiorna la scena ad ogni frame, l'\textit{engine}, la scena, la telecamera, la luce e tutta
una serie di funzionalità dedite al corretto avvio di una scena XR (se è stato rilevato un dispositivo affine).\\
Queste due classi sono le uniche in tutta la \textit{codebase} a non autodistruggersi all'avvento del `game over'. Se così non fosse, al termine della partita l'utente si ritroverebbe
con una schermata vuota e dovrebbe ricaricare la pagina per avviare una nuova sessione. Per aggirare il problema si è deciso di cambiare il comportamento che hanno queste classi al 
termine della partita, facendo sì che ricreino la scena (e anche i dati) da zero.\\

\subsection{Game}\label{subsec:game}
\subsection{Player}\label{subsec:player}
\subsection{LifePoints}\label{subsec:lifepoints}
\subsection{Hand}\label{subsec:hand}
\subsection{Turn}\label{subsec:turn}
\subsection{Battlefield}\label{subsec:battlefield}

Cose da dire:
\begin{itemize}
\item Definiti questi princìpi cardine si sono quindi costruite le fondamenta su cui basare il video game. La classe più importante, da cui poi si sviluppa tutta la struttura, è 
\texttt{GameModel}. Questa classe di fatto non gestisce una struttura dati ma fa da contenitore per tutti i modelli del gioco. Qui si trovano i riferimenti ai modelli dei giocatori,
del turno e del campo di battaglia.\\
Altra funzionalità importante per questa classe è di gestire le connessioni e i ruoli. All'avvio, in base al numero di partecipanti già presenti, questa classe avrà il compito di 
assegnare un ruolo al nuovo utente connesso scegliendo tra \textit{player 1}, \textit{player 2} e \textit{spettatore}. Inoltre, se un utente dovesse disconnettersi, questa classe
dovrà gestire una sua possibile riconnessione come anche prevedere una sequenza di terminazione nel caso in cui l'utente non dovesse riconnettersi.\\
Nella controparte \texttt{GameView} si possono trovare gli stessi riferimenti alle view corrispondenti dei modelli citati. Si noti che, dato che il model non contiene una struttura
dati, la \texttt{GameView} non crea alcun componente visibile all'utente, mantenendo coerenza con il principio di specularità tra model e view.\\
\end{itemize}