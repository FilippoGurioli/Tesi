\section{Progettazione dettagliata}\label{sec:progettazione}
In quest'ultima sezione si affronteranno le strutture del progetto nello specifico, analizzando i requisiti del progetto e come questi siano stati implementati nel concreto.\\
\newline
Prima di iniziare con la descrizione, si vuole esporre dei punti chiave comuni lungo tutto il progetto. Seguendo la logica del \textit{single-responsibility principle}\footnote{
    Single responsibility principle: principio di progettazione software che afferma che ogni modulo o classe deve essere responsabile di una singola funzionalità.
}, si è strutturata una rete di \texttt{Croquet.Model} che distribuisse ogni funzionalità del dominio ad un modello diverso, in modo da 
tenere separati i compiti e mantenere una gerarchia ordinata e intuitiva.\\
Altro tassello importante è la decisione di non utilizzare ereditarietà, preferendo la composizione inquanto ritenuta più flessibile e meno vincolante. La struttura si può
raffigurare comunque in una relazione padre-figlio in cui però non è il figlio a estendere il padre, bensì il padre a creare e contenere il figlio. Si tenga presente che in questa
valutazione non è stato preso in considerazione l'estensione di tutte le classi da \texttt{Croquet.Model} e \texttt{Croquet.View} inquanto obbligatorio per il funzionamento di Croquet.\\
In ultima istanza si sono create delle classi JavaScript ausiliarie all'architettura di Croquet che fungono da supporto per la gestione dei dati. Queste classi sono state create per 
racchiudere al loro interno le caratteristiche più importanti dei concetti da modellare e quindi facilitare la manutenzione e migliorare la leggibilità del codice.\\

\subsection{Visualizzazione degli ologrammi personali e condivisi in tempo reale}
Si definisce ologramma condiviso un ologramma che è visibile da tutti gli utenti connessi alla sessione. Al contrario, un ologramma personale è un oggetto di scena che può essere diverso
da utente a utente e talvolta anche non esserci.\\
Per realizzare un ologramma condiviso basterà creare nella view un oggetto di scena con coordinate assolute. Visto che tutti gli utenti eseguono lo stesso codice, quando
dovranno istanziare l'ologramma condiviso lo faranno tutti allo stesso modo. Per il medesimo motivo, quando il model lancia un evento per comunicare l'aggiornamento dello stato, tutte le 
view lo riceveranno aggiornando l'ologramma alla stessa maniera.\\
Per creare un ologramma personale si è ricorsi all'istanziamento degli oggetti in modo condizionale. Questo significa che, in base a certe condizioni, vengono creati oggetti di scena 
diversi. Nel caso particolare del videogioco, ad esempio, se l'utente è un player ed è il suo turno verrà mostrato un
\textit{near menu}, ovvero un menù capace di seguire l'utente (nativo di MRTK e integrato in BabylonJS), per procedere di fase, al contrario, se non è il suo turno o se non è un
player, non verrà mostrato nulla. Si fornisce il codice~\ref{lst:ologrammi.js} come esempio. 
\code{ologrammi.js}{Esempio di istanziazione di ologrammi personali e condivisi.}

\subsection{Interazioni del giocatore}
Per tutte le interazioni del giocatore lungo tutto il corso del progetto si è seguito sempre lo stesso pattern:
\begin{enumerate}
    \item l'utente interagisce con un oggetto di scena;
    \item l'oggetto di scena lancia un evento;
    \item il model riceve l'evento e aggiorna lo stato;
    \item in base a come è costruita la view:
    \begin{enumerate} 
        \item se la view utilizza il metodo \texttt{\_update} per aggiornare la scena, il model non fa nulla;
        \item altrimenti il model lancia un evento per comunicare l'aggiornamento dello stato alla view;
    \end{enumerate} 
    \item la view aggiorna la scena.
\end{enumerate} 
Si prenda d'esempio l'interazione con la mano del giocatore. L'utente interagisce con una carta tra quelle presenti nello spazio personale, la carta lancia un evento \textit{`playCard'}
che viene intercettato del model corrispondente \texttt{HandModel}. Questo verifica che ci siano le condizioni adatte per poter giocare la carta e, se così fosse, aggiorna lo stato
rimuovendo la carta dalla mano e aggiungendola al campo di battaglia. Il model quindi lancia due eventi: uno per rimuovere la carta dalla mano ed uno per aggiungere la carta al
campo di battaglia. La view \texttt{HandView} riceve l'evento \textit{`removeCard'} e rimuove la carta dallo spazio personale, mentre la view \texttt{BattlefieldView} riceve l'evento
\textit{`placeCard'} e crea la carta nel campo di battaglia. Si riporta il codice~\ref{lst:interazioni.js} che illustra quanto detto.
\code{interazioni.js}{Esempio di interazione tra utente e oggetto di scena con conseguente aggiornamento dello stato tramite eventi.}

Per lasciare un esempio anche delle interazioni che coinvolgono l'utilizzo della \texttt{\_udpdate}, si prenda in considerazione l'interazione che l'utente svolge per cambiare la 
fase di gioco. All'utente viene fornito un \textit{near menu} che contiene un pulsante per avanzare di fase. L'utente interagisce con il bottone che lancia un evento 
\textit{`nextPhase'} intercettato dal model \texttt{TurnModel} che aggiorna lo stato. Tornando alla \texttt{TurnView}, nel suo metodo \texttt{\_update}, controlla se lo stato sia
cambiata e, in caso affermativo, aggiorna la scena. Si faccia riferimento al listato~\ref{lst:ologrammi.js} precedentemente mostrato per capire come è stato implementata questa
interazione.


\subsection{Gestione delle connessioni}
Nel progetto si è dato un peso rilevante a tutta la parte di gestione delle connessioni e disconnessioni degli utenti. Si sono create infrastrutture apposite che sapessero controllare
e mantenere in uno stato coerente le connessioni di tutti i giocatori.\\
Questo compito lo si è affidato alle classi \texttt{GameModel} e \texttt{GameView}, figlie dirette delle \textit{root classes}, ovvero le prime classi create nel progetto.
Queste classi hanno il compito di gestire le comunicazioni e di istanziare tutti i modelli e le viste del gioco. Si sono dovute gestire tutte le casistiche possibili, come la 
connessione di un nuovo giocatore, la disconnessione temporanea di un giocatore, la riconnessione di un giocatore e la disconnessione definitiva di un giocatore. 
Per dare una panoramica generale di come si è risolto il problema si lascia il codice~\ref{lst:connessioni.js} d'esempio. Nel listato è stata omessa la classe \texttt{GameView} per 
brevità, preferendo una spiegazione discorsiva delle funzionalità.\\
La classe \texttt{GameView} attua tutte le sue logiche attraverso l'utilizzo di quattro eventi diversi.
\begin{itemize}
    \item Ascolta l'evento \textit{`join-response'}: lanciato dopo che il model ha calcolato quale ruolo rappresenti la view appena connessa nella sessione in corso. In base al ruolo
    assegnato, la view istanzierà le view corrispondenti e posizionerà la telecamera dell'utente in modo da avere una visione ottimale della scena.
    \item Ascolta l'evento \textit{`opponent-left'}: lanciato quando un giocatore si disconnette temporaneamente dalla sessione. La view interromperà il normale flusso di gioco, 
    mostrando agli utenti rimasti una schermata d'attesa.
    \item Ascolta l'evento \textit{`opponent-recover'}: lanciato quando un giocatore si riconnette alla sessione. La view farà riprendere la scena da dove era stata interrotta.
    \item Ascolta l'evento \textit{`game-over'}: lanciato quando un giocatore si disconnette definitivamente dalla sessione. La view distruggerà la scena e ricreerà quella di base.
\end{itemize}
\code{connessioni.js}{Infrastruttura per la gestione delle connessioni.}
Un altro aspetto importante che è stato gestito è la possibilità di riavviare la simulazione senza dover ricaricare la pagina. Se tutte le classi si autodistruggessero alla fine del
gioco, l'utente si ritroverebbe con una schermata vuota e dovrebbe ricaricare la pagina per avviare una nuova sessione. Per aggirare il problema si è deciso di cambiare il 
comportamento che hanno le \textit{root classes} al termine della partita, facendo sì che ricreino la scena (e anche i dati) da zero anzichè distruggersi, come mostrato nel 
codice~\ref{lst:root.js}.
\code{root.js}{Creazione e riavvio della simulazione.}

\subsection{Estendibilità nelle parti critiche}
Si è fatta particolare attenzione anche al trovare un modo per rendere il più facilmente estendible parti critiche del progetto. L'area che necessitava di più attenzione era quella
relativa alle carte da gioco. Si voleva rendere l'aggiunta, la modifica e la rimozione delle carte il più semplice possibile, a tal punto che anche un non programmatore potesse 
metterci mano. Trattandosi di carte collezionabili, ovvero un insieme di carte in continua produzione e sempre diverse, non si poteva pensare ad una struttura dati statica, come si 
farebbe per un normale mazzo di carte francesi. Si è quindi pensato di creare un file JSON che contenesse tutte le informazioni necessarie per creare una carta. Questo file è stato
poi letto e mappato in una struttura dati JavaScript che potesse essere utilizzata dal resto del progetto. Si è scelto di utilizzare un file JSON per la sua semplicità di lettura e
modifica. Anche un non programmatore potrebbe essere in grado, una volta letti i primi esempi presenti nel file, di aggiungere, modificare o rimuovere carte. Si lascia il
file sorgente al listato~\ref{lst:card.json}.
\code{card.json}{Esempio di file JSON contenente le informazioni di carte \textit{Yu-Gi-Oh!}.}