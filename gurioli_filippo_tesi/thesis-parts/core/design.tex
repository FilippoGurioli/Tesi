\section{Design architetturale}\label{sec:design}
In questo paragrafo si scenderà nel dettaglio dell'architettura del sistema, descrivendo le scelte progettuali effettuate per il corretto funzionamento delle tecnologie adottate.\\
\newline
Il framework di base da cui si è sviluppato il progetto è Croquet. La documentazione cita che per una buona realizzazione di un progetto Croquet bisogna cercare di mantenere una 
struttura speculare tra model e view. Nel primo vengono immagazzinate le informazioni e nella seconda vengono visualizzati i dati in base al tipo di utente che ci vuole accedere.
Ogni \texttt{Croquet.Model} dovrà essere completamente indipendente dal framework di visualizzazione, in modo da poter essere utilizzato in qualsiasi contesto. Al contrario, nelle
\texttt{Croquet.View} si dovranno trovare solo componenti visibili all'utente, senza alcuna logica di business.\\
Croquet gestisce i dati condivisi creando una loro istanza all'interno di ogni client e sincronizzandoli tramite l'utilizzo dei reflector. Per comprendere meglio il funzionamento
dei passaggi successivi, si consiglia di immaginare questi dati come all'interno di un server fittizio a cui ogni client ha accesso come mostrato in figura~\ref{fig:CroquetServer.png}.\\
\img{CroquetServer.png}{In alto la vera struttura di Croquet, in basso una rappresentazione semplificata.}
Al contrario del model, ogni view va vista come una istanza di realtà aumentata unica per ogni utente. Ogni giocatore è immerso nella propria simulazione WebXR con un proprio engine,
una priopria camera e i propri oggetti di scena. Queste simulazioni interagiscono tra loro grazie agli eventi: all'interazione dell'utente con gli oggetti di scena, la view invia un
evento al model che lo elabora, modifica il proprio stato e aggiorna le view degli altri utenti come mostrato in figura~\ref{fig:MultiUserBABYLON.png}.\\
\img{MultiUserBABYLON.png}{Ogni utente ha la propria istanza di BabylonJS.}
\newline
In ausilio all'architettura di Croquet sono state anche progettate classi Javascript standard che fungono da supporto per la gestione dei dati. Queste classi sono state create per 
racchiudere al loro interno le caratteristiche più importanti dei concetti da modellare e quindi facilitare la manutenzione e migliorare la leggibilità del codice.\\
\newline
Un ultimo aspetto dell'architettura da considerare è la creazione di una API che adattasse le classi \textit{general-purpose} di Croquet alle specifiche del progetto. Queste classi si pongono
in mezzo tra i model e le view utilizzate nell'elaborato e quelle di Croquet, modificando e riadattando le feature già presenti nel framework e aggiungendone di nuove. Nello specifico
si è deciso di implementare una \texttt{BaseView} ed un \texttt{BaseModel} che ereditassero rispettivamente da \texttt{Croquet.View} e \texttt{Croquet.Model}, dai quali poi estenderanno
tutte le altre view e i modelli del progetto.\\
Il \texttt{BaseModel} riporta le seguenti feature:
\begin{itemize}
    \item \textbf{automatizzazione della parentela}: ogni modello creato con queste classe avrà un riferimento al modello padre;
    \item \textbf{creazione di un log personalizzato}: ogni modello avrà un log personalizzato con il proprio nome, utile per il debug;
    \item \textbf{gestione della distruzione}: ogni modello ascolterà l'evento `game-over' avente come \textit{scope} il \textit{session ID} di modo che, in qualunque momento, in qualsiasi
    punto del codice, se il componente valuta che la partita sia terminata, può lanciare questo evento e distruggere il modello;
    \item \textbf{nuova inizializzazione}: ogni modello disporrà di due metodi da definire, \texttt{\_initialize} che fa le veci del vecchio \texttt{init}, ora utilizzato per il funzionamento
    del \texttt{BaseModel}, e \texttt{\_subscribeAll} in cui vanno inserite tutte le sottoscrizioni che quel modello deve effettuare.
\end{itemize}
Si noti che la separazione tra \texttt{\_initialize} e \texttt{\_subscribeAll} è solo a scopo di leggibilità del codice. Queste funzioni vengono chiamate entrambe all'avvio del modello, per
tanto non risulterebbe un problema se si facesse una sottoscrizione in \texttt{\_intialize} piuttosto che una inizializzazione di variabile in \texttt{\_subscribeAll}.\\
Prima di procedere con l'elenco delle funzionalità della \texttt{BaseView} si vuole sottolineare che quando si parlerà di molteplici view, non si farà riferimento ad esse in senso
\textit{orizzontale}, ovvero che ogni view contraddistingua un utente diverso, bensì in senso \textit{verticale}, ovvero che ogni utente disponga di più view, ognuna delle quali mostra
oggetti diversi (si faccia riferimento alla figura\ref{fig:MultiViews.png}).\\
\img{MultiViews.png}{Visione \textit{verticale} e \textit{orizzontale} delle view a confronto.}
Le feature che presenta la \texttt{BaseView} sono:
\begin{itemize}
    \item \textbf{automatizzazione della parentela}: ogni view creata con questa classe avrà un riferimento alla view padre;
    \item \textbf{automatizzazione del riferimento al model}: ogni view creata con questa classe avrà un riferimento al model corrispettivo;
    \item \textbf{creazione di un log personalizzato}: ogni view avrà un log personalizzato con il proprio nome, utile per il debug;
    \item \textbf{nuova inizializzazione}: ogni view disporrà di tre metodi da definire, \texttt{\_initialize} che fa le veci del vecchio \texttt{init}, ora utilizzato per il funzionamento
    della \texttt{BaseView}, \texttt{\_subscribeAll} in cui vanno inserite tutte le sottoscrizioni che quella view deve effettuare e \texttt{\_initializeScene} che deve contenere tutte le
    inizializzazioni relative ad oggetti di scena;
    \item \textbf{automatizzazione dell'aggiornamento}: un punto cieco dell'architettura di Croquet è che la chiamata del metodo \texttt{update} non viene perpetrata da una view all'altra.
    Fornendo una lista \texttt{children} riempita con i riferimenti a tutte le view figlie, la \texttt{BaseView} potrà accedere a tutte le view dalle quali poi richiamare i rispettivi
    \texttt{update} così da sopperire alla mancanza di Croquet. Viene fornito anche un metodo \texttt{\_update} da sovrascrivere per aggiungere funzionalità all'aggiornamento;
    \item \textbf{gestione della distruzione}: ogni view ascolterà l'evento `game-over' avente come \textit{scope} il \textit{session ID} di modo che, se venisse lanciato, la view
    si distrugga automaticamente. Per attuare ciò viene lasciata una lista \texttt{sceneObjects} da riempire con tutte le \textit{mesh}\footnote{Mesh: è un insieme di vertici, spigoli e 
    poligoni che formano un modello tridimensionale.} di BabylonJS istanziate in modo tale che,
    alla chiamata di distruzione, la \texttt{BaseView} possa distruggere anch'essi. Inoltre, essendo una UI, si è previsto che le view avessero bisogno di un tempo d'attesa prima di 
    cancellare tutta la scena, affinchè ogni oggetto faccia la sua uscita di scena e/o mostri informazioni riguardanti il termine del gioco. Per realizzare ciò si è costruito un metodo 
    da estendere chiamato \texttt{\_endScene} nel quale effettuare tutte le animazioni del caso e che restituisca il numero di millisecondi da aspettare prima di lanciare il comando di 
    \texttt{detach};
    \item \textbf{informazioni condivise}: si è creata una struttura dati che fosse accessibile da tutte le viste e che racchiudesse le informazioni univoche per ogni partita come una sorta
    di \textit{singleton pattern}. Qui si possono trovare informazioni come il riferimento all'\textit{engine} di BabylonJS utilizzato, alla scena o alla telecamera.
\end{itemize}
Fino ad ora si sono esposte le scelte progettuali effettuate per la realizzazione del progetto. Nel prossimo capitolo si vedranno più nel dettaglio le funzionalità implementate in ogni
classe che compone il progetto.