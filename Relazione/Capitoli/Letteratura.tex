\chapter{Stato dell'arte}\label{chap:Letteratura}
Di seguito si riporteranno informazioni circa lo stato dell'arte riguardante
tecnologie e metodologie utilizzate per lo sviluppo di videogiochi e come 
vengano adattate alla realtà aumentata. Si affronteranno le problematiche della 
gestione cooperativa dell'esperienza di gioco e quali tecnologie ne permettano 
la realizzazione. Infine si darà una panoramica delle strutture messe a 
disposizione per creare mondi virtuali attualmente presenti in letteratura.

\section{Game Programming Pattern}\label{sec:GameProgrammingPattern}
% In questa sezione si farà principalmente riferimento al libro \textit{''Game Programming Patterns''}
% di Robert Nystrom\cite{Nystrom2014}, in cui vengono descritti i pattern più comuni nel
% game design. Nel testo vengono citate 5 macrocategorie:
% \begin{itemize}
%     \item Design Pattern rivisitati,
%     \item sequencing pattern,
%     \item pattern comportamentali,
%     \item pattern di disaccoppiamento,
%     \item pattern di ottimizzazione.
% \end{itemize}

\subsection{Design Pattern rivisitati}\label{ssec:DesignPattern}
% I design pattern sono i pattern più comuni e noti, sono stati descritti per la prima
% volta nel libro \textit{''Design Patterns: Elements of Reusable Object-Oriented Software''}
% ~\cite{gangof4}. Nel libro di Nystrom vengono rivisitati alcuni di questi pattern
% in chiave videoludica ed in particolare si analizzano i seguenti: Command, Flyweight,
% Observer, Prototype, Singleton e State. Data la vastità di argomenti che copre quel libro
% non verranno analizzati tutti, bensì solo quelli che si ritengono più rilevanti per
% questo progetto di tesi.

\paragraph{Command Pattern}
% Il command pattern è definito nel libro come \textit{''la reificazione 
% di una chiamata di funzione''}, in pratica si tratta di modellare una classe
% che permetta di creare un livello di astrazione tra quando un comando
% viene invocato e quando viene eseguito. Si crea un'interfaccia `Command'
% che specifica solo un metodo `execute', dopodichè si creano delle classi
% che implementano tale interfaccia e che rappresentino un comando ben specifico
% (e.g. salta, corri, attacca etc.). Nella sua essenza il command pattern è quanto
% appena detto ma il modo in cui viene utilizzato è forse la cosa più interessante:
% nell'ipotetica classe `InputHandler' si potrà dichiarare una istanza della classe
% `Command' per ogni tipo di interazione che l'utente può eseguire (e.g. premere un tasto,
% drag and drop, gestures di vario genere etc.) ed assegnare a questo oggetto una qualsiasi
% delle classi precedentemente definite, svincolando così l'interazione dall'esecuzione
% di un determinato evento. I vantaggi del command pattern, spiega Nystrom, non si
% fermano solo alla possibilità di creare il key binding ma, serializzando i comandi,
% si possono mandare in rete per realizzare un gioco multiplayer. Si lascia il codice
% ~\ref{lst:commandPattern.ts} come esemplificazione di quanto appena spiegato.
% \code{commandPattern.ts}{Codice d'esempio per l'implementazione del command pattern.}

\paragraph{Observer pattern}
% L'observer pattern è uno dei più famosi e più utilizzati pattern presenti in
% letteratura. La stessa Microsoft ne ha fornito una implementazione all'interno del framework 
% .NET. L'observer pattern si basa sui concetti di \textit{evento} e \textit{osservatore}:
% quando un oggetto modifica il suo stato e produce un qualche risultato visibile
% genera un \textit{evento}. Questo può essere osservato dall'\textit{osservatore} 
% che, a sua volta, può reagire all'evento stesso, eseguendo del codice. Questa idea
% ribalta il concetto normalmente utilizzato in cui per permettere ad un oggetto B
% di reagire ad un cambiamento di stato di un oggetto A, quest'ultimo deve avere
% un riferimento all'oggetto B. Questo pattern crea un layer di astrazione tra l'oggetto
% che genera l'evento e l'oggetto che vuole reagirci, svincolando il generatore dal
% conoscere l'osservatore. Nel contesto di un videogioco questo pattern è spesso usato in modo
% verticale su tutta la codebase, a partire dalla gestione generale di eventi di gioco fino ad arrivare
% alla gestione di contesti particolari come la gestione degli input, degli achievements o delle
% collisioni. Data la grande versatilità del pattern è facile che possa sfuggire di mano,
% inserendolo anche dove basterebbe usare una banalissima chiamata di metodo. Per questo
% Nystrom fornisce un semplice criterio da seguire per evitare di cadere in errore: 
% il pattern, spiega, andrebbe applicato ogni qualvolta l'oggetto che genera l'evento
% non ha senso che conosca l'osservatore, l'esempio lampante che viene fornito anche nel libro
% è il voler implementare un achievement alla prima volta che si viaggia ad una certa
% velocità verticale (si cade). Nel modo più semplice basterebbe mettere nel sistema che
% gestisce la fisica un controllo che verifica se le condizioni si avverano, 
% nel qual caso chiamare un metodo del sistema di achievement `unlockAchievement' per 
% completare l'operazione. In questo scenario il motore fisico dovrebbe avere
% un riferimento alla classe di Achievement; al contrario se il motore fisico
% generasse un evento non preoccupandosi di chi reagisce a questo ecco che il vincolo
% referenziale non esisterebbe più. Si lascia il codice ~\ref{lst:observerPattern.ts} come esempio
% di implementazione del pattern observer.
% \code{observerPattern.ts}{Codice d'esempio per l'implementazione dell'observer pattern.}

\subsection{Sequencing pattern}\label{ssec:SequencingPattern}
% I sequencing pattern sono pattern che permettono di gestire il tempo di gioco,
% ovvero la sequenza di eventi che caratterizzano il passare del tempo all'interno
% di un gioco. Si analizzeranno quindi i seguenti pattern: Game Loop e Update Method.

\paragraph{Game Loop}
% È risaputo che i videogiochi rompano il concetto di macchina di Turing, ovvero
% non esiste un concetto di input, calcolo e output, dopo il quale il programma termina.
% Al contrario l'eseprienza di gioco risulta in un flusso continuo di operazioni, questo
% flusso ininterrotto è dato proprio dal game loop. Il game loop è un pattern che
% permette di gestire il tempo di gioco, ovvero il passare del tempo all'interno
% di un gioco. Il game loop è un ciclo infinito che si occupa di gestire gli input,
% aggiornare la logica di gioco e renderizzare il frame corrente. 
% \code{gameLoop1.ts}{Game loop semplice.}
% Le sue caratteristiche permettono di scindere il tempo reale dal tempo di gioco 
% sfruttando il concetto di frame rate. Il frame rate è il numero di frame che 
% vengono renderizzati in un secondo. Se non ci fosse alcun controllo sul framerate a 
% cui viaggia il gioco si riscontrerebbero ambiguità per cui se un pc è più 
% potente di un altro il gioco viaggerà più veloce sul primo che sul secondo, 
% con conseguenze ancora peggiori se i due giocatori stessero giocando alla 
% stessa partita in multiplayer. Per questo motivo il game loop è anche 
% responsabile di rendere il gioco indipendente dal framerate, ovvero di 
% aggiornare la logica di gioco in base al tempo trascorso dall'ultimo aggiornamento
% e non in base al numero di frame renderizzati. Per realizzare ciò (nel
% modo più semplice) si sceglie un framerate a cui far andare il gioco (e.g. 60 
% fps) e si calcola il tempo che intercorre tra un frame e l'altro (e.g. 16.6 ms),
% facendo attendere il gioco se avanzasse tempo (e.g. 60 - 16.6 = 43.4ms).
% \img{GameLoopLogics.png}{Logica di gestione del tempo nel game loop.}
% \code{gameLoop2.ts}{Game loop con gestione del tempo.}

\paragraph{Update Method}

\subsection{Pattern di disaccoppiamento}\label{ssec:PatternDisaccoppiamento}
\paragraph{Component pattern}
\paragraph{Event queue}
placeholder
\\\newline
Si noti che sono stati analizzati solo alcuni dei pattern presenti nel libro di 
Nystrom, per una trattazione più approfondita si rimanda al libro stesso. Le scelte
delle tematiche sono state fatte per brevità e per rilevanza rispetto al progetto
di tesi.

\section{Framework per la gestione cooperativa}\label{sec:Cooperativa}
\subsection{Reti}\label{ssec:Reti}
\subsection{Client-Server e peer-to-peer}\label{ssec:CS&P2P}
\subsection{Croquet}\label{ssec:IntroCroquet}

\section{Framework per sviluppo 3D}\label{sec:FW3D}
\subsection{Blender}\label{ssec:Blender}
\subsection{Unity}\label{ssec:Unity}
\subsection{BabylonJS}\label{ssec:IntroBabylonJS}