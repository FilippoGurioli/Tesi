\chapter{Stato dell'arte}\label{chap:Letteratura}
Di seguito si riporteranno informazioni circa lo stato dell'arte riguardante
tecnologie e metodologie utilizzate per lo sviluppo di videogiochi e come 
vengano adattate alla realtà aumentata. Si affronteranno le problematiche della 
gestione cooperativa dell'esperienza di gioco e quali tecnologie ne permettano 
la realizzazione. Infine si darà una panoramica delle strutture messe a 
disposizione per creare mondi virtuali attualmente presenti in letteratura.

\section{Game Design Pattern}\label{sec:GameDesignPattern}
In questa sezione si farà principalmente riferimento al libro \textit{''Game Programming Patterns''}
di Robert Nystrom\cite{Nystrom2014}, in cui vengono descritti i pattern più comuni nel
game design. Nel testo vengono citate 5 macrocategorie di pattern:
\begin{itemize}
    \item Design Pattern rivisitati;
    \item Sequencing pattern;
    \item Pattern comportamentali;
    \item Pattern di disaccoppiamento;
    \item Pattern di ottimizzazione.
\end{itemize}
Di seguito si riporta una breve descrizione per ognuna di esse e se ne analizzano
i pattern più significativi.

\subsection{Design Pattern rivisitati}\label{ssec:DesignPattern}
I design pattern sono i pattern più comuni e noti, sono stati descritti per la prima
volta nel libro \textit{''Design Patterns: Elements of Reusable Object-Oriented Software''}
~\cite{gangof4}. Nel libro di Nystrom vengono rivisitati alcuni di questi pattern
in chiave videoludica ed in particolare si analizzano i seguenti: Command, Flyweight,
Observer, Prototype, Singleton e State. Data la vastità di argomenti che copre quel libro
non verranno analizzati tutti, bensì solo quelli che si ritengono più rilevanti per
questo progetto di tesi.
\paragraph{Command Pattern}
Il command pattern è definito nel libro come \textit{''la reificazione 
di una chiamata di funzione''}, in pratica si tratta di modellare una classe
che permetta di creare un livello di astrazione tra quando un comando
viene invocato e quando viene eseguito. Si crea un'interfaccia `Command'
che specifica solo un metodo `execute', dopodichè si creano delle classi
che implementano tale interfaccia e che rappresentino un comando ben specifico
(e.g. salta, corri, attacca etc.). Nella sua essenza il command pattern è quanto
appena detto ma il modo in cui viene utilizzato è forse la cosa più interessante:
nell'ipotetica classe `InputHandler' si potrà dichiarare una istanza della classe
`Command' per ogni tipo di interazione che l'utente può eseguire (e.g. premere un tasto,
drag and drop, gestures di vario genere etc.) ed assegnare a questo oggetto una qualsiasi
delle classi precedentemente definite, svincolando così l'interazione dall'esecuzione
di un determinato evento. I vantaggi del command pattern, spiega Nystrom, non si
fermano solo alla possibilità di creare il key binding ma, serializzando i comandi,
si possono mandare in rete per realizzare un gioco multiplayer. Si lascia il codice
~\ref{lst:commandPattern.ts} come esemplificazione di quanto appena spiegato.
\code{commandPattern.ts}{Codice d'esempio per l'implementazione del command pattern}

\paragraph{Observer pattern}
L'observer pattern è uno dei più famosi e più utilizzati pattern presenti in
letteratura. La stessa Microsoft ne ha fornito una implementazione all'interno del framework 
.NET. L'observer pattern si basa sui concetti di \textit{evento} e \textit{osservatore}:
quando un oggetto modifica il suo stato e produce un qualche risultato visibile
genera un \textit{evento} il quale può essere osservato dall'\textit{osservatore} 
che, a sua volta, può reagire, eseguendo del codice, all'evento stesso. Questa idea
ribalta il concetto normalmente utilizzato in cui per permettere ad un oggetto B
di reagire ad un cambiamento di stato di un oggetto A, quest'ultimo deve avere
un riferimento all'oggetto B. Questo pattern crea un layer di astrazione tra l'oggetto
che genera l'evento e l'oggetto che vuole reagirci svincolando il generatore dal
conoscere l'osservatore. Nel contesto di un videogioco questo pattern è spesso usato in modo
verticale su tutta la codebase, a partire dalla gestione generale di eventi di gioco fino ad arrivare
alla gestione di contesti particolari come la gestione degli input, degli achievements o delle
collisioni./*qui inserire il fatto che l'applicazione del pattern potrebbe sfuggire di mano*/ 
Nystrom spiega che il pattern andrebbe applicato ogni qualvolta l'oggetto che genera l'evento
non ha senso che conosca l'osservatore. Si lascia il codice ~\ref{lst:observerPattern.ts} come esempio
di implementazione del pattern observer.

\section{Framework per la gestione cooperativa}\label{sec:Cooperativa}

\section{Framework per sviluppo 3D}\label{sec:FW3D}